# InitializeProject Workflow

**Trigger:** First use of Diataxis-Documentation skill in a project, OR explicit "set up docs", "initialize documentation", "create docs site".

**Purpose:** Configure and scaffold a documentation site for this specific project.

---

## Version Check (Run First)

**Check for skill updates before proceeding:**

```bash
SKILL_FILE="${PAI_DIR:-$HOME/.claude}/skills/Diataxis-Documentation/SKILL.md"

# Read version and sources from frontmatter
INSTALLED_VERSION=$(grep -E "^version:" "$SKILL_FILE" | cut -d' ' -f2)
OFFICIAL_SOURCE=$(grep -E "^official_source:" "$SKILL_FILE" | cut -d' ' -f2)
OFFICIAL_PATH=$(grep -E "^official_source_path:" "$SKILL_FILE" | cut -d' ' -f2)

# Defaults
OFFICIAL_SOURCE="${OFFICIAL_SOURCE:-https://github.com/danielmiessler/Personal_AI_Infrastructure}"
OFFICIAL_PATH="${OFFICIAL_PATH:-Packs/pai-diataxis-documentation-skill}"

# Fetch latest version from official source
RAW_URL=$(echo "$OFFICIAL_SOURCE" | sed 's|github.com|raw.githubusercontent.com|')
REMOTE_SKILL="$RAW_URL/main/$OFFICIAL_PATH/src/skills/Diataxis-Documentation/SKILL.md"

LATEST_VERSION=$(curl -s "$REMOTE_SKILL" 2>/dev/null | grep -E "^version:" | head -1 | cut -d' ' -f2 || echo "unknown")

echo "Installed: $INSTALLED_VERSION"
echo "Latest: $LATEST_VERSION"

if [ "$LATEST_VERSION" != "unknown" ] && [ "$INSTALLED_VERSION" != "$LATEST_VERSION" ]; then
  echo ""
  echo "â¬†ï¸ UPDATE AVAILABLE: $INSTALLED_VERSION â†’ $LATEST_VERSION"
fi
```

**If update available, inform user:**
```
"Note: A newer version of Diataxis-Documentation skill is available ($INSTALLED_VERSION â†’ $LATEST_VERSION).
You can update later with: 'check for Diataxis skill updates'

Continuing with initialization..."
```

---

## Detection & Resume

**Check for existing project configuration and determine mode:**

```bash
mkdir -p ./docs

if [ -f "./docs/.diataxis.md" ]; then
  INIT_STATUS=$(grep -E "^init_status:" ./docs/.diataxis.md | sed 's/^init_status: //')
  if [ "$INIT_STATUS" = "complete" ]; then
    echo "STATUS: complete"
  elif [ "$INIT_STATUS" = "in_progress" ]; then
    echo "STATUS: in_progress"
    echo ""
    echo "=== Saved Answers ==="
    grep -E "^(sources|purpose|roles|diataxis_|hosting|technology):" ./docs/.diataxis.md || echo "(none)"
  else
    echo "STATUS: unknown (treating as in_progress)"
  fi
else
  echo "STATUS: none"
fi
```

**Mode handling:**

| Status | Action |
|--------|--------|
| `complete` | Skip to other workflows (PlanDocumentation, etc.) |
| `in_progress` | Resume mode - show saved answers, offer to modify or continue |
| `none` | Fresh start - begin from Question 1 |

### Resume Mode (if in_progress)

**Present saved answers and ask how to proceed:**

```json
{
  "header": "Resume",
  "question": "Found incomplete initialization. How would you like to proceed?",
  "multiSelect": false,
  "options": [
    {"label": "Continue from where I left off", "description": "Keep saved answers, continue to next unanswered question"},
    {"label": "Review and modify answers", "description": "Go through each saved answer with option to change"},
    {"label": "Start fresh", "description": "Clear saved answers and restart from beginning"}
  ]
}
```

**If "Review and modify":** For each saved answer, show current value and ask:
```
"Sources: [Existing docs/, Code comments]
Keep this answer or change it?"
```

**If "Start fresh":**
```bash
rm -f ./docs/.diataxis.md
```

---

## Progressive Save Format

**After EACH question is answered, immediately save to `docs/.diataxis.md`:**

```bash
# Create/update config file with current progress
cat > ./docs/.diataxis.md << 'EOF'
<!-- Diataxis Documentation Configuration -->
<!-- Auto-generated by InitializeProject workflow -->

init_status: in_progress

## Saved Answers (in progress)

sources:
1. **Primary:** [url/path] â€” [description]
2. **[category]:** [url/path] â€” [description]

purpose: [selected purpose]
roles: [list of selected roles]
diataxis_developers: [list of content types]
diataxis_users: [list of content types]
hosting: [selected hosting]
technology: [selected technology]
EOF
```

**Questions are saved with these keys:**
- Phase 1 â†’ `sources:` (multi-line, numbered, with priority and description)
- Phase 2 â†’ `context:` (within_project | standalone_docs)
- Q2 â†’ `purpose:`
- Q3 â†’ `roles:`
- Q4 â†’ `diataxis_<role>:` (one per role)
- Q5 â†’ `hosting:`
- Q6 â†’ `technology:`

---

## Phase 1: Discover Sources

**CRITICAL:** Discover sources automatically BEFORE asking the user. Scan the project environment, then present findings for confirmation.

The old approach (static checklist of 5 filesystem options) is replaced by intelligent discovery that proposes prioritized sources with descriptions â€” matching the quality of a hand-curated source list.

### 1.1 Auto-Detect Project Environment

Run all detection steps in a single pass:

```bash
# === Git & Repository Detection ===
ORIGIN_URL=""
UPSTREAM_URL=""
IS_FORK=false
REPO_NAME=""
REPO_OWNER=""
REPO_VISIBILITY="unknown"
REPO_DESCRIPTION=""
REPO_HOMEPAGE=""
REPO_STARS=0
REPO_HAS_DISCUSSIONS=false
REPO_HAS_WIKI=false
PARENT_REPO=""

if [ -d ".git" ]; then
  ORIGIN_URL=$(git remote get-url origin 2>/dev/null || echo "")
  UPSTREAM_URL=$(git remote get-url upstream 2>/dev/null || echo "")

  # Normalize git@ URLs to https
  normalize_url() {
    echo "$1" | sed 's|git@github.com:|https://github.com/|' | sed 's|\.git$||'
  }
  [ -n "$ORIGIN_URL" ] && ORIGIN_URL=$(normalize_url "$ORIGIN_URL")
  [ -n "$UPSTREAM_URL" ] && UPSTREAM_URL=$(normalize_url "$UPSTREAM_URL")

  echo "ORIGIN: ${ORIGIN_URL:-none}"
  echo "UPSTREAM: ${UPSTREAM_URL:-none}"
fi

# GitHub API enrichment (if gh CLI available)
if command -v gh &> /dev/null && [ -n "$ORIGIN_URL" ]; then
  GH_JSON=$(gh repo view --json name,owner,visibility,description,homepageUrl,stargazerCount,hasDiscussionsEnabled,hasWikiEnabled,isFork,parent 2>/dev/null || echo "{}")

  REPO_NAME=$(echo "$GH_JSON" | jq -r '.name // empty')
  REPO_OWNER=$(echo "$GH_JSON" | jq -r '.owner.login // empty')
  REPO_VISIBILITY=$(echo "$GH_JSON" | jq -r '.visibility // "unknown"')
  REPO_DESCRIPTION=$(echo "$GH_JSON" | jq -r '.description // empty')
  REPO_HOMEPAGE=$(echo "$GH_JSON" | jq -r '.homepageUrl // empty')
  REPO_STARS=$(echo "$GH_JSON" | jq -r '.stargazerCount // 0')
  REPO_HAS_DISCUSSIONS=$(echo "$GH_JSON" | jq -r '.hasDiscussionsEnabled // false')
  REPO_HAS_WIKI=$(echo "$GH_JSON" | jq -r '.hasWikiEnabled // false')
  IS_FORK=$(echo "$GH_JSON" | jq -r '.isFork // false')
  PARENT_REPO=$(echo "$GH_JSON" | jq -r '.parent.owner.login + "/" + .parent.name // empty' 2>/dev/null)

  # If this is a fork but no upstream remote, infer it
  if [ "$IS_FORK" = "true" ] && [ -z "$UPSTREAM_URL" ] && [ -n "$PARENT_REPO" ]; then
    UPSTREAM_URL="https://github.com/$PARENT_REPO"
  fi

  echo "REPO: $REPO_OWNER/$REPO_NAME"
  echo "VISIBILITY: $REPO_VISIBILITY"
  echo "DESCRIPTION: $REPO_DESCRIPTION"
  echo "HOMEPAGE: ${REPO_HOMEPAGE:-none}"
  echo "STARS: $REPO_STARS"
  echo "IS_FORK: $IS_FORK"
  [ "$IS_FORK" = "true" ] && echo "PARENT: $PARENT_REPO"
  echo "DISCUSSIONS: $REPO_HAS_DISCUSSIONS"
  echo "WIKI: $REPO_HAS_WIKI"
fi

# === Project Type Detection ===
HAS_CODE=false
PROJECT_TYPE="Unknown"

if [ -f "package.json" ]; then
  HAS_CODE=true; PROJECT_TYPE="Node.js"
elif [ -f "pyproject.toml" ] || [ -f "setup.py" ] || [ -f "requirements.txt" ]; then
  HAS_CODE=true; PROJECT_TYPE="Python"
elif [ -f "go.mod" ]; then
  HAS_CODE=true; PROJECT_TYPE="Go"
elif [ -f "Cargo.toml" ]; then
  HAS_CODE=true; PROJECT_TYPE="Rust"
elif [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
  HAS_CODE=true; PROJECT_TYPE="Java"
elif [ -d "src" ] || [ -d "lib" ] || [ -d "app" ]; then
  HAS_CODE=true; PROJECT_TYPE="Unknown (has src/lib/app)"
fi

echo "PROJECT_TYPE: $PROJECT_TYPE"
echo "HAS_CODE: $HAS_CODE"

# === Author/Maintainer Detection ===
AUTHOR_NAME=""
AUTHOR_URL=""

# Try package.json
if [ -f "package.json" ]; then
  AUTHOR_NAME=$(jq -r '.author // .author.name // empty' package.json 2>/dev/null)
  AUTHOR_URL=$(jq -r '.author.url // .homepage // empty' package.json 2>/dev/null)
fi

# Try pyproject.toml
if [ -z "$AUTHOR_NAME" ] && [ -f "pyproject.toml" ]; then
  AUTHOR_NAME=$(grep -E "^authors" pyproject.toml 2>/dev/null | head -1 | sed 's/.*"\(.*\)".*/\1/')
fi

# Try GitHub repo owner profile
if [ -z "$AUTHOR_URL" ] && [ -n "$REPO_OWNER" ] && command -v gh &> /dev/null; then
  OWNER_JSON=$(gh api "users/$REPO_OWNER" --jq '{blog: .blog, bio: .bio}' 2>/dev/null || echo "{}")
  AUTHOR_URL=$(echo "$OWNER_JSON" | jq -r '.blog // empty')
fi

echo "AUTHOR: ${AUTHOR_NAME:-unknown}"
echo "AUTHOR_URL: ${AUTHOR_URL:-none}"

# === Local Content Detection ===
DOC_COUNT=0; README_COUNT=0; HAS_OPENAPI=false; HAS_DESIGN_DOCS=false
HAS_DOCS_SITE=false; DOCS_TECH=""

[ -d "./docs" ] && DOC_COUNT=$(find ./docs -name "*.md" 2>/dev/null | wc -l | tr -d ' ')
README_COUNT=$(find . -maxdepth 3 -name "README*.md" 2>/dev/null | wc -l | tr -d ' ')
([ -f "openapi.yaml" ] || [ -f "openapi.json" ] || [ -f "swagger.yaml" ]) && HAS_OPENAPI=true
([ -d "./specs" ] || [ -d "./rfcs" ] || [ -d "./design" ]) && HAS_DESIGN_DOCS=true
[ -f "docusaurus.config.js" ] || [ -f "docusaurus.config.ts" ] && HAS_DOCS_SITE=true && DOCS_TECH="Docusaurus"
[ -f "mkdocs.yml" ] && HAS_DOCS_SITE=true && DOCS_TECH="MkDocs"
[ -f "astro.config.mjs" ] && HAS_DOCS_SITE=true && DOCS_TECH="Astro"

echo "DOCS: $DOC_COUNT files"
echo "READMES: $README_COUNT"
echo "OPENAPI: $HAS_OPENAPI"
echo "DESIGN_DOCS: $HAS_DESIGN_DOCS"
echo "DOCS_SITE: $HAS_DOCS_SITE ($DOCS_TECH)"
```

### 1.2 Build Proposed Source List

**Using the detection results, construct a prioritized source list.** The AI agent assembles this â€” it is not a bash script. Use the following logic:

#### Source Categories

| Category | When to Include | Priority |
|----------|----------------|----------|
| **Primary repo** | Always (if git repo detected) | 1 (highest) |
| **Upstream/parent repo** | If fork detected or upstream remote exists | 1 or 2 |
| **Author content** | If author website/blog found, or repo owner has public profile | 2-3 |
| **Local content** | If existing docs, code comments, API specs, design docs found | included in primary repo description |
| **Community/third-party** | If public repo with significant stars (>100) | 3-4 |
| **Fork additions** | If this is a fork with local changes | 3-4 |

#### Construction Rules

1. **Primary source gets the richest description.** Include sub-sources: repo documentation, code, GitHub Discussions (if enabled), Issues, Wiki (if enabled). Mention key contributors if detectable.

2. **For forks:** The upstream/parent repo is typically the primary source. The fork itself becomes a secondary source for local additions/changes. Example:
   ```
   1. **Primary:** https://github.com/owner/project â€” repo documentation, code, GitHub Discussions, Issues
   2. **Fork additions:** https://github.com/you/project â€” updates and additions by @you
   ```

3. **Author content:** If the repo owner or author has a website, blog, or YouTube channel, include it. These provide context, rationale, and explanations that code alone doesn't capture.
   ```
   2. **Author content:** author's website, blog posts, articles, YouTube videos
   ```

4. **Third-party coverage:** For popular public projects (>100 stars), suggest including external analysis. For private/small projects, omit this category.
   ```
   3. **Third-party coverage:** High-quality reviews, commentary, articles, videos by well-regarded sources
   ```

5. **Local content details** are folded into the primary repo description, not listed separately. Instead of "Code comments: 45 JSDoc blocks", describe what's available:
   ```
   1. **Primary:** https://github.com/owner/project â€” repo documentation (23 docs), code (JSDoc), Issues, Discussions
   ```

#### Example Proposed Source Lists

**For a fork of a popular project:**
```
## Documentation Sources (Priority Order)

1. **Primary:** https://github.com/danielmiessler/PAI â€” repo documentation, code, GitHub Discussions, Issues (especially Daniel Miessler's contributions)
2. **Author content:** Daniel Miessler's website, blog posts, articles, YouTube videos
3. **Third-party coverage:** High-quality reviews, commentary, articles, videos by well-regarded sources
4. **Fork additions:** https://github.com/virtualian/pai â€” updates and additions by @virtualian
```

**For a standalone project:**
```
## Documentation Sources (Priority Order)

1. **Primary:** https://github.com/acme/widget-sdk â€” repo documentation (12 docs), code (JSDoc, 156 blocks), README files (4), OpenAPI spec
2. **Design documents:** specs/ directory (3 RFCs), architecture decision records
```

**For a private internal project:**
```
## Documentation Sources (Priority Order)

1. **Primary:** local project â€” code (Python docstrings, 89 found), existing docs/ (7 files)
2. **Design documents:** design/ directory, internal wiki
```

### 1.3 Present Proposed Sources for Confirmation

**Show the user what you discovered and the proposed source list:**

```
"I've analyzed your project environment and built a proposed source list:

ðŸ”§ Project: [owner/name] ([visibility])
ðŸ”€ Fork of: [parent] (if applicable)
ðŸ“„ Local content: [X docs, Y code comments, etc.]
ðŸŒ Author: [name] ([website if found])

Here's my proposed source list:

## Documentation Sources (Priority Order)

1. **Primary:** [...]
2. **[category]:** [...]
[etc.]

Does this look right? You can adjust priorities, add sources, or remove any."
```

**Then ask for confirmation:**

```json
{
  "header": "Sources",
  "question": "How should I handle this proposed source list?",
  "multiSelect": false,
  "options": [
    {"label": "Use as-is (Recommended)", "description": "The proposed sources and priorities look correct"},
    {"label": "Modify sources", "description": "I want to add, remove, or reprioritize sources"},
    {"label": "Start from scratch", "description": "Ignore detection, I'll specify sources manually"}
  ]
}
```

**If "Modify sources":** Ask the user what to change. Use follow-up AskUserQuestion calls for each modification (add source, remove source, change priority, edit description).

**If "Start from scratch":** Ask the user to describe their sources as free text, then format into the prioritized structure.

### 1.4 Save Sources

**After confirmation, save immediately:**

```bash
mkdir -p ./docs
cat > ./docs/.diataxis.md << 'SOURCES_EOF'
init_status: in_progress
sources:
1. **Primary:** [url/path] â€” [description with sub-sources]
2. **[category]:** [url/path or description] â€” [details]
SOURCES_EOF
```

**The sources block is multi-line.** It starts after `sources:` and continues until the next config key. The final Phase 5 config reads it with:

```bash
# Read multi-line sources block (from "sources:" until next config key or EOF)
SOURCES=$(sed -n '/^sources:/,/^[a-z_]*:/{ /^sources:/d; /^[a-z_]*:/d; p; }' ./docs/.diataxis.md)
```

---

## Phase 2: Analyze Sources and Detect Context

**Using the discovered sources and detection results from Phase 1.**

### 2.1 Confirm Documentation Context

**Based on Phase 1 detection, confirm with user:**

```json
{
  "header": "Context",
  "question": "Where are you creating this documentation?",
  "multiSelect": false,
  "options": [
    {"label": "Within a project (Recommended)", "description": "Adding docs to an existing codebase - creates docs/ folder alongside code"},
    {"label": "Standalone docs repo", "description": "Dedicated documentation repository - site lives at root level"}
  ]
}
```

**Recommendation logic:**
- If `HAS_CODE=true` â†’ recommend "Within a project"
- If `HAS_CODE=false` â†’ recommend "Standalone docs repo"

**After answer, save immediately:**
```bash
echo "context: [within_project | standalone_docs]" >> ./docs/.diataxis.md
```

**This affects site structure:**

| Context | Docs Location | Site Location |
|---------|---------------|---------------|
| Within project | `docs/` | `website/` (Docusaurus) or `site/` (MkDocs) |
| Standalone docs | root or `docs/` | root level build |

### 2.2 Check for Existing Docs Site

```bash
[ -f "docusaurus.config.js" ] || [ -f "docusaurus.config.ts" ] && echo "EXISTING_SITE: Docusaurus"
[ -f "mkdocs.yml" ] && echo "EXISTING_SITE: MkDocs"
[ -f "astro.config.mjs" ] && echo "EXISTING_SITE: Astro Starlight"
```

### 2.3 Present Analysis Summary

```
"Based on source discovery:

ðŸ”§ Project type: [Node.js | Python | Go | etc.]
ðŸ”’ Repo visibility: [Public | Private | Unknown]
ðŸ”€ Fork: [Yes (parent: owner/repo) | No]
ðŸ“„ Local content: [X docs, Y code comment blocks, Z READMEs]
ðŸŒ Docs site: [Docusaurus | MkDocs | None detected]

Sources configured â€” moving to documentation purpose and roles."
```

---

## Phase 3: Remaining Questions

**IMPORTANT:** Ask remaining 5 questions. Each builds on sources selected AND analysis from Phase 2.

### Question Order (Dependencies)

```
Sources âœ“ (Phase 1)
    â†“
Context âœ“ (Phase 2 - within project vs standalone)
    â†“
Purpose (informed by context + sources)
    â†“
Roles (informed by purpose + sources)
    â†“
Diataxis Priorities (informed by roles + sources)
    â†“
Hosting (informed by purpose + repo visibility)
    â†“
Technology (informed by hosting + purpose + project type)
```

---

### Question 2: Purpose (first question in Phase 3)

**Recommend based on sources found.**

```json
{
  "header": "Purpose",
  "question": "What is the primary purpose of your documentation site?",
  "multiSelect": false,
  "options": [
    {"label": "Developer Portal (Recommended)", "description": "API docs, SDK guides, integration tutorials for developers"},
    {"label": "Product Documentation", "description": "User guides, feature docs, help center for end users"},
    {"label": "Internal/Team Docs", "description": "Engineering docs, runbooks, architecture decisions"},
    {"label": "Open Source Project", "description": "README-driven, contributor guides, community docs"}
  ]
}
```

**Recommendation logic based on sources:**

| Sources Found | Recommended Purpose |
|--------------|---------------------|
| OpenAPI spec, JSDoc, API code | Developer Portal |
| User-facing app, no API | Product Documentation |
| Internal tooling, runbooks | Internal/Team Docs |
| GitHub public repo, CONTRIBUTING.md | Open Source Project |

**After answer, save immediately:**
```bash
# Append purpose to config
echo "purpose: [selected purpose]" >> ./docs/.diataxis.md
```

---

### Question 3: Roles/Audiences

**Recommend based on purpose + sources.**

```json
{
  "header": "Roles",
  "question": "What roles/audiences does your documentation serve?",
  "multiSelect": true,
  "options": [
    {"label": "Developers", "description": "People writing code against your project"},
    {"label": "Users", "description": "End users of your application or library"},
    {"label": "Operators", "description": "DevOps, SRE, people deploying and running your system"},
    {"label": "Contributors", "description": "Open source contributors to your project"}
  ]
}
```

**Recommendation logic:**

| Purpose | Recommended Roles |
|---------|-------------------|
| Developer Portal | Developers (primary), Operators |
| Product Documentation | Users (primary), Operators |
| Internal/Team Docs | Developers, Operators |
| Open Source Project | Developers, Contributors |

**After answer, save immediately:**
```bash
# Append roles to config
echo "roles: [selected roles]" >> ./docs/.diataxis.md
```

---

### Question 4: Diataxis Priorities

**Ask for EACH role selected. Recommendations based on available sources.**

```json
{
  "header": "[Role] Docs",
  "question": "For [ROLE], which Diataxis content types are most important?",
  "multiSelect": true,
  "options": [
    {"label": "Tutorials", "description": "Learning-oriented content for newcomers"},
    {"label": "How-to Guides", "description": "Task-oriented guides for accomplishing specific goals"},
    {"label": "Reference", "description": "Technical specifications, API docs, configuration options"},
    {"label": "Explanation", "description": "Conceptual content explaining why things work"}
  ]
}
```

**Recommendation logic based on sources:**

| Source Available | Can Recommend |
|-----------------|---------------|
| OpenAPI spec, JSDoc | Reference âœ“ |
| Existing tutorials in docs/ | Tutorials âœ“ |
| Code examples | How-to Guides âœ“ |
| Design docs, architecture | Explanation âœ“ |

**If source doesn't exist for a content type, note it:**
```
"Note: Reference docs recommended, but I didn't find API specs or JSDoc.
You'll need to add code comments or manually write reference content."
```

**After answer (for each role), save immediately using this exact format:**

```bash
# CRITICAL: Save as 4 comma-separated markers (âœ“ or -) in order: Tutorials,How-to,Reference,Explanation
# Example: User selects "Tutorials" and "Reference" for developers:
echo "diataxis_developers: âœ“,-,âœ“,-" >> ./docs/.diataxis.md

# Example: User selects "How-to Guides" and "Explanation" for users:
echo "diataxis_users: -,âœ“,-,âœ“" >> ./docs/.diataxis.md

# Example: User selects all four for operators:
echo "diataxis_operators: âœ“,âœ“,âœ“,âœ“" >> ./docs/.diataxis.md
```

**Format specification:**
- Always save exactly 4 comma-separated values
- Order is: `Tutorials,How-to,Reference,Explanation`
- Use `âœ“` for selected, `-` for not selected
- This format is required for Phase 5 parsing

---

### Question 5: Hosting

**Recommend based on purpose + repo visibility.**

```json
{
  "header": "Hosting",
  "question": "Where will your documentation be hosted?",
  "multiSelect": false,
  "options": [
    {"label": "GitHub Pages", "description": "Free, git-integrated, works with most static site generators"},
    {"label": "Vercel/Netlify", "description": "Modern JAMstack hosting with preview deployments"},
    {"label": "Self-hosted", "description": "Your own infrastructure (nginx, S3, etc.)"},
    {"label": "Docs platform", "description": "ReadMe, GitBook, Notion, or similar managed platform"}
  ]
}
```

**Recommendation logic:**

| Factors | Recommended Hosting |
|---------|-------------------|
| Public GitHub repo | GitHub Pages (free, integrated) |
| Private repo (no Enterprise) | Vercel/Netlify (free tier available) |
| Private repo + GitHub Enterprise | GitHub Pages or Vercel/Netlify |
| Enterprise/on-prem requirements | Self-hosted |
| Managed experience preferred | Docs platform (ReadMe, GitBook) |

**Note:** GitHub Pages requires public repos OR GitHub Enterprise subscription for private repos.

**After answer, save immediately:**
```bash
echo "hosting: [selected hosting]" >> ./docs/.diataxis.md
```

---

### Question 6: Technology

**Recommend based on hosting + purpose + project type.**

```json
{
  "header": "Technology",
  "question": "Which documentation technology should we use?",
  "multiSelect": false,
  "options": [
    {"label": "Docusaurus", "description": "React-based, versioning, search, MDX support - great for developer portals"},
    {"label": "MkDocs + Material", "description": "Python-based, clean design, simpler setup - great for technical docs"},
    {"label": "Astro Starlight", "description": "Fast, modern, component islands - great for performance"},
    {"label": "Plain Markdown", "description": "No build step, GitHub renders directly - great for simple projects"}
  ]
}
```

**Recommendation logic:**

| Factors | Recommended Technology |
|---------|----------------------|
| Docs platform (ReadMe, GitBook) | Plain Markdown (platform handles rendering) |
| GitHub Pages + simple project | Plain Markdown |
| Node.js project + Developer Portal | Docusaurus |
| Python project + any purpose | MkDocs Material |
| Existing Docusaurus setup | Docusaurus (keep existing) |
| Existing MkDocs setup | MkDocs (keep existing) |
| Performance critical | Astro Starlight |

**After answer, save immediately:**
```bash
echo "technology: [selected technology]" >> ./docs/.diataxis.md
```

---

## Phase 4: Scaffold Documentation Site

**Based on context AND technology choice, scaffold the docs site.**

**Read context and technology from saved answers:**
```bash
CONTEXT=$(grep -E "^context:" ./docs/.diataxis.md | sed 's/^context: //')
TECHNOLOGY=$(grep -E "^technology:" ./docs/.diataxis.md | sed 's/^technology: //')

echo "CONTEXT: $CONTEXT"
echo "TECHNOLOGY: $TECHNOLOGY"
```

---

### Conditional Scaffold Selection

**CRITICAL:** Execute ONLY the section matching the user's technology choice. Do NOT create scaffolds for other technologies.

```
if TECHNOLOGY = "Docusaurus"
    â†’ Execute "Docusaurus" section below
else if TECHNOLOGY = "MkDocs + Material"
    â†’ Execute "MkDocs + Material" section below
else if TECHNOLOGY = "Astro Starlight"
    â†’ Execute "Astro Starlight" section below
else if TECHNOLOGY = "Plain Markdown"
    â†’ Execute "Plain Markdown" section below
```

Within each technology section, use CONTEXT to determine structure:
- `within_project` â†’ docs site in subdirectory, code at root
- `standalone_docs` â†’ docs site at root level

---

### Docusaurus

**Execute this section ONLY if `TECHNOLOGY = "Docusaurus"`**

```bash
# Check context and run appropriate command
if [ "$CONTEXT" = "within_project" ]; then
  # Site in website/, docs content in website/docs/
  npx create-docusaurus@latest website classic --typescript --skip-install
elif [ "$CONTEXT" = "standalone_docs" ]; then
  # Site at root level
  npx create-docusaurus@latest . classic --typescript --skip-install
fi
```

**Within project structure (`CONTEXT = "within_project"`):**
```
project/
â”œâ”€â”€ src/                    # Your code
â”œâ”€â”€ website/                # Docusaurus site
â”‚   â”œâ”€â”€ docs/               # Documentation content (role-first)
â”‚   â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”‚   â”œâ”€â”€ tutorials/
â”‚   â”‚   â”‚   â””â”€â”€ how-to/
â”‚   â”‚   â””â”€â”€ developers/
â”‚   â”‚       â”œâ”€â”€ tutorials/
â”‚   â”‚       â”œâ”€â”€ how-to/
â”‚   â”‚       â”œâ”€â”€ reference/
â”‚   â”‚       â””â”€â”€ explanation/
â”‚   â”œâ”€â”€ src/                # Custom pages, components
â”‚   â”œâ”€â”€ docusaurus.config.js
â”‚   â””â”€â”€ sidebars.js
â””â”€â”€ package.json            # Your project
```

**Standalone docs repo structure (`CONTEXT = "standalone_docs"`):**
```
docs-repo/
â”œâ”€â”€ docs/                   # Documentation content (role-first)
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ tutorials/
â”‚   â”‚   â””â”€â”€ how-to/
â”‚   â””â”€â”€ developers/
â”‚       â”œâ”€â”€ tutorials/
â”‚       â”œâ”€â”€ reference/
â”‚       â””â”€â”€ explanation/
â”œâ”€â”€ src/                    # Custom pages, components
â”œâ”€â”€ docusaurus.config.js
â””â”€â”€ sidebars.js
```

---

### MkDocs + Material

**Execute this section ONLY if `TECHNOLOGY = "MkDocs + Material"`**

```bash
# Create docs folder - role structure created in Phase 6
mkdir -p docs

# Create mkdocs.yml at appropriate location
# Note: nav structure updated in Phase 6 after roles are processed
if [ "$CONTEXT" = "within_project" ]; then
  cat > mkdocs.yml << 'MKDOCS_EOF'
site_name: Project Documentation
docs_dir: docs
theme:
  name: material
# nav: configured after role structure is created
MKDOCS_EOF
elif [ "$CONTEXT" = "standalone_docs" ]; then
  cat > mkdocs.yml << 'MKDOCS_EOF'
site_name: Documentation
docs_dir: docs
theme:
  name: material
# nav: configured after role structure is created
MKDOCS_EOF
fi

# Create index.md
cat > docs/index.md << 'EOF'
# Welcome

[TODO: Add project overview]
EOF
```

**Within project structure (`CONTEXT = "within_project"`):**
```
project/
â”œâ”€â”€ src/                    # Your code
â”œâ”€â”€ docs/                   # Documentation content (role-first)
â”‚   â”œâ”€â”€ index.md
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ tutorials/
â”‚   â”‚   â””â”€â”€ how-to/
â”‚   â””â”€â”€ developers/
â”‚       â”œâ”€â”€ tutorials/
â”‚       â”œâ”€â”€ reference/
â”‚       â””â”€â”€ explanation/
â”œâ”€â”€ mkdocs.yml              # MkDocs config at project root
â””â”€â”€ package.json            # Your project
```

**Standalone docs repo structure (`CONTEXT = "standalone_docs"`):**
```
docs-repo/
â”œâ”€â”€ docs/                   # Documentation content (role-first)
â”‚   â”œâ”€â”€ index.md
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ tutorials/
â”‚   â”‚   â””â”€â”€ how-to/
â”‚   â””â”€â”€ developers/
â”‚       â”œâ”€â”€ reference/
â”‚       â””â”€â”€ explanation/
â””â”€â”€ mkdocs.yml
```

---

### Astro Starlight

**Execute this section ONLY if `TECHNOLOGY = "Astro Starlight"`**

```bash
if [ "$CONTEXT" = "within_project" ]; then
  # Site in docs/, content in docs/src/content/docs/
  npm create astro@latest docs -- --template starlight --skip-houston --no-install
  # Role structure created in Phase 6
elif [ "$CONTEXT" = "standalone_docs" ]; then
  # Site at root level
  npm create astro@latest . -- --template starlight --skip-houston --no-install
  # Role structure created in Phase 6
fi
```

**Within project structure (`CONTEXT = "within_project"`):**
```
project/
â”œâ”€â”€ src/                    # Your code
â”œâ”€â”€ docs/                   # Starlight site
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â””â”€â”€ content/
â”‚   â”‚       â””â”€â”€ docs/       # Documentation content (role-first)
â”‚   â”‚           â”œâ”€â”€ index.mdx
â”‚   â”‚           â”œâ”€â”€ users/
â”‚   â”‚           â”‚   â”œâ”€â”€ tutorials/
â”‚   â”‚           â”‚   â””â”€â”€ how-to/
â”‚   â”‚           â””â”€â”€ developers/
â”‚   â”‚               â”œâ”€â”€ reference/
â”‚   â”‚               â””â”€â”€ explanation/
â”‚   â”œâ”€â”€ astro.config.mjs
â”‚   â””â”€â”€ package.json
â””â”€â”€ package.json            # Your project
```

**Standalone docs repo structure (`CONTEXT = "standalone_docs"`):**
```
docs-repo/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ content/
â”‚       â””â”€â”€ docs/           # Documentation content (role-first)
â”‚           â”œâ”€â”€ index.mdx
â”‚           â”œâ”€â”€ users/
â”‚           â”‚   â”œâ”€â”€ tutorials/
â”‚           â”‚   â””â”€â”€ how-to/
â”‚           â””â”€â”€ developers/
â”‚               â”œâ”€â”€ reference/
â”‚               â””â”€â”€ explanation/
â”œâ”€â”€ astro.config.mjs
â””â”€â”€ package.json
```

---

### Plain Markdown

**Execute this section ONLY if `TECHNOLOGY = "Plain Markdown"`**

```bash
if [ "$CONTEXT" = "within_project" ]; then
  # Docs in docs/ subdirectory - role structure created in Phase 6
  mkdir -p docs
  cat > docs/README.md << 'EOF'
# Documentation

[TODO: Add documentation overview]

Browse documentation by role below.
EOF
elif [ "$CONTEXT" = "standalone_docs" ]; then
  # Docs at root level - role structure created in Phase 6
  cat > README.md << 'EOF'
# Documentation

[TODO: Add documentation overview]

Browse documentation by role below.
EOF
fi
```

**Within project structure (`CONTEXT = "within_project"`):**
```
project/
â”œâ”€â”€ src/                    # Your code
â”œâ”€â”€ docs/                   # Documentation (role-first)
â”‚   â”œâ”€â”€ README.md           # Index
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ tutorials/
â”‚   â”‚   â””â”€â”€ how-to/
â”‚   â””â”€â”€ developers/
â”‚       â”œâ”€â”€ reference/
â”‚       â””â”€â”€ explanation/
â””â”€â”€ README.md               # Project readme (not Diataxis)
```

**Standalone docs repo structure (`CONTEXT = "standalone_docs"`):**
```
docs-repo/
â”œâ”€â”€ README.md               # Index
â”œâ”€â”€ users/
â”‚   â”œâ”€â”€ tutorials/
â”‚   â””â”€â”€ how-to/
â””â”€â”€ developers/
    â”œâ”€â”€ reference/
    â””â”€â”€ explanation/
```

---

## Phase 5: Finalize Project Configuration

**Transform progressive saves into final config format and mark complete.**

**Read skill version and saved answers:**

```bash
SKILL_VERSION=$(grep -E "^version:" "${PAI_DIR:-$HOME/.claude}/skills/Diataxis-Documentation/SKILL.md" | cut -d' ' -f2)

# Read saved answers from progressive saves
# Sources are multi-line: read from "sources:" until next config key
SOURCES=$(sed -n '/^sources:/,/^[a-z_]*:/{/^sources:/d; /^[a-z_]*:/d; p;}' ./docs/.diataxis.md)
CONTEXT=$(grep -E "^context:" ./docs/.diataxis.md | sed 's/^context: //')
PURPOSE=$(grep -E "^purpose:" ./docs/.diataxis.md | sed 's/^purpose: //')
ROLES=$(grep -E "^roles:" ./docs/.diataxis.md | sed 's/^roles: //')
HOSTING=$(grep -E "^hosting:" ./docs/.diataxis.md | sed 's/^hosting: //')
TECHNOLOGY=$(grep -E "^technology:" ./docs/.diataxis.md | sed 's/^technology: //')
```

**Rewrite `docs/.diataxis.md` as final config (with init_status: complete):**

```bash
# Get current date
CURRENT_DATE=$(date +%Y-%m-%d)

# Read diataxis priorities for each role (if they exist)
DIATAXIS_DEVELOPERS=$(grep -E "^diataxis_developers:" ./docs/.diataxis.md 2>/dev/null | sed 's/^diataxis_developers: //' || echo "")
DIATAXIS_USERS=$(grep -E "^diataxis_users:" ./docs/.diataxis.md 2>/dev/null | sed 's/^diataxis_users: //' || echo "")
DIATAXIS_OPERATORS=$(grep -E "^diataxis_operators:" ./docs/.diataxis.md 2>/dev/null | sed 's/^diataxis_operators: //' || echo "")
DIATAXIS_CONTRIBUTORS=$(grep -E "^diataxis_contributors:" ./docs/.diataxis.md 2>/dev/null | sed 's/^diataxis_contributors: //' || echo "")

# Write final configuration file
cat > ./docs/.diataxis.md << EOF
<!-- config-version: $SKILL_VERSION -->
# Diataxis Documentation Configuration

> Auto-generated by Diataxis-Documentation skill v$SKILL_VERSION on $CURRENT_DATE

init_status: complete
last_actioned: $CURRENT_DATE

## Site Configuration

- **Context:** $CONTEXT
- **Purpose:** $PURPOSE
- **Hosting:** $HOSTING
- **Technology:** $TECHNOLOGY

## Documentation Sources (Priority Order)

$SOURCES

## Roles & Audiences

| Role | Priority |
|------|----------|
$(echo "$ROLES" | tr ',' '\n' | tr '[:upper:]' '[:lower:]' | sed '/^[[:space:]]*$/d' | nl -ba | while read num role; do
  role=$(echo "$role" | xargs)  # trim whitespace
  [ -z "$role" ] && continue
  case $num in
    1) priority="primary" ;;
    2) priority="secondary" ;;
    *) priority="tertiary" ;;
  esac
  echo "| $role | $priority |"
done)

## Diataxis Elements by Role

| Role | Tutorials | How-to | Reference | Explanation |
|------|-----------|--------|-----------|-------------|
$(echo "$ROLES" | tr ',' '\n' | tr '[:upper:]' '[:lower:]' | while read role; do
  role=$(echo "$role" | xargs)  # trim whitespace
  [ -z "$role" ] && continue
  case "$role" in
    developers) priorities="$DIATAXIS_DEVELOPERS" ;;
    users) priorities="$DIATAXIS_USERS" ;;
    operators) priorities="$DIATAXIS_OPERATORS" ;;
    contributors) priorities="$DIATAXIS_CONTRIBUTORS" ;;
    *) priorities="" ;;
  esac
  if [ -n "$priorities" ]; then
    # Parse 4 comma-separated markers: âœ“ or - in order Tutorials,How-to,Reference,Explanation
    # Format saved in Phase 3: "âœ“,-,âœ“,-" means Tutorials=yes, How-to=no, Reference=yes, Explanation=no
    t=$(echo "$priorities" | cut -d',' -f1 | xargs)
    h=$(echo "$priorities" | cut -d',' -f2 | xargs)
    r=$(echo "$priorities" | cut -d',' -f3 | xargs)
    e=$(echo "$priorities" | cut -d',' -f4 | xargs)
    # Validate we have all 4 fields (fallback to - if missing)
    [ -z "$t" ] && t="-"
    [ -z "$h" ] && h="-"
    [ -z "$r" ] && r="-"
    [ -z "$e" ] && e="-"
    echo "| $role | $t | $h | $r | $e |"
  else
    echo "| $role | - | - | - | - |"
  fi
done)

## Files Exempt from Diataxis Reorganization

These files serve platform/repo purposes and should NOT be reorganized into Diataxis content type directories. They may still be used as **source material** when generating documentation.

Exempt files in this project:
$(ls -1 README.md LICENSE CONTRIBUTING.md CHANGELOG.md CODE_OF_CONDUCT.md SECURITY.md 2>/dev/null | while read f; do echo "- $f"; done)

> **Note:** Files in source repositories (listed in Documentation Sources above) are valid sources regardless of this exemption list. This list only governs local file reorganization.
EOF

echo "âœ“ Configuration finalized: ./docs/.diataxis.md"
```

**CRITICAL:** The `init_status: complete` line marks initialization as finished. Without this, the workflow will treat the project as incomplete on next invocation.

---

## Phase 6: Create Initial Structure

**Based on technology, context, and role priorities, create role-first starter files.**

**Read configuration:**
```bash
TECHNOLOGY=$(grep -E "^technology:" ./docs/.diataxis.md | sed 's/^technology: //')
CONTEXT=$(grep -E "^context:" ./docs/.diataxis.md | sed 's/^context: //')
ROLES=$(grep -E "^roles:" ./docs/.diataxis.md | sed 's/^roles: //')

echo "Creating structure for: $TECHNOLOGY ($CONTEXT)"
echo "Roles: $ROLES"
```

**Determine docs content path based on technology and context:**

| Technology | Context | Content Path |
|------------|---------|--------------|
| Docusaurus | within_project | `website/docs/` |
| Docusaurus | standalone_docs | `docs/` |
| MkDocs + Material | either | `docs/` |
| Astro Starlight | within_project | `docs/src/content/docs/` |
| Astro Starlight | standalone_docs | `src/content/docs/` |
| Plain Markdown | within_project | `docs/` |
| Plain Markdown | standalone_docs | root level |

```bash
# Set DOCS_PATH based on technology and context
case "$TECHNOLOGY" in
  "Docusaurus")
    [ "$CONTEXT" = "within_project" ] && DOCS_PATH="website/docs" || DOCS_PATH="docs"
    ;;
  "MkDocs + Material")
    DOCS_PATH="docs"
    ;;
  "Astro Starlight")
    [ "$CONTEXT" = "within_project" ] && DOCS_PATH="docs/src/content/docs" || DOCS_PATH="src/content/docs"
    ;;
  "Plain Markdown")
    [ "$CONTEXT" = "within_project" ] && DOCS_PATH="docs" || DOCS_PATH="."
    ;;
esac

echo "Content path: $DOCS_PATH"
```

**Create role-first folder structure:**

```bash
# Loop through each role and create role-first structure
echo "$ROLES" | tr ',' '\n' | while read role; do
  role=$(echo "$role" | xargs | tr '[:upper:]' '[:lower:]')
  [ -z "$role" ] && continue

  # Get priorities for this role (format: âœ“,-,âœ“,- for Tutorials,How-to,Reference,Explanation)
  DIATAXIS_KEY="diataxis_${role}"
  PRIORITIES=$(grep -E "^${DIATAXIS_KEY}:" ./docs/.diataxis.md | sed "s/^${DIATAXIS_KEY}: //")

  HAS_TUTORIALS=$(echo "$PRIORITIES" | cut -d',' -f1 | xargs)
  HAS_HOWTO=$(echo "$PRIORITIES" | cut -d',' -f2 | xargs)
  HAS_REFERENCE=$(echo "$PRIORITIES" | cut -d',' -f3 | xargs)
  HAS_EXPLANATION=$(echo "$PRIORITIES" | cut -d',' -f4 | xargs)

  # Create role directory with its content type subdirectories
  echo "Creating structure for role: $role"
  mkdir -p "$DOCS_PATH/$role"
  [ "$HAS_TUTORIALS" = "âœ“" ] && mkdir -p "$DOCS_PATH/$role/tutorials"
  [ "$HAS_HOWTO" = "âœ“" ] && mkdir -p "$DOCS_PATH/$role/how-to"
  [ "$HAS_REFERENCE" = "âœ“" ] && mkdir -p "$DOCS_PATH/$role/reference"
  [ "$HAS_EXPLANATION" = "âœ“" ] && mkdir -p "$DOCS_PATH/$role/explanation"
done
```

**Create index file (technology-specific):**

```bash
case "$TECHNOLOGY" in
  "Docusaurus")
    cat > "$DOCS_PATH/intro.md" << 'EOF'
---
sidebar_position: 1
---

# Introduction

Welcome to the documentation.

[TODO: Add project overview]
EOF
    ;;
  "MkDocs + Material"|"Astro Starlight")
    cat > "$DOCS_PATH/index.md" << 'EOF'
# Introduction

Welcome to the documentation.

[TODO: Add project overview]
EOF
    ;;
  "Plain Markdown")
    # Already created in Phase 4
    ;;
esac
```

**Create placeholder indexes for each role and content type:**

```bash
create_section_index() {
  local path="$1"
  local title="$2"
  local desc="$3"

  if [ -d "$path" ]; then
    cat > "$path/index.md" << EOF
# $title

$desc

[TODO: Add content]
EOF
  fi
}

# Create indexes for each role and its content types
echo "$ROLES" | tr ',' '\n' | while read role; do
  role=$(echo "$role" | xargs | tr '[:upper:]' '[:lower:]')
  [ -z "$role" ] && continue

  # Create role landing page
  role_title=$(echo "$role" | sed 's/.*/\u&/')  # Capitalize first letter
  create_section_index "$DOCS_PATH/$role" "$role_title Documentation" "Documentation for ${role}."

  # Create content type indexes within role
  create_section_index "$DOCS_PATH/$role/tutorials" "Tutorials" "Learning-oriented guides for ${role}."
  create_section_index "$DOCS_PATH/$role/how-to" "How-to Guides" "Task-oriented guides for ${role}."
  create_section_index "$DOCS_PATH/$role/reference" "Reference" "Technical specifications for ${role}."
  create_section_index "$DOCS_PATH/$role/explanation" "Explanation" "Conceptual content for ${role}."
done
```

---

## Phase 7: GitHub Actions (if GitHub Pages)

**If hosting is GitHub Pages, create workflow:**

```yaml
# .github/workflows/docs.yml
name: Deploy Documentation

on:
  push:
    branches: [main]
    paths:
      - 'website/**'
      - 'docs/**'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Install dependencies
        run: npm ci
        working-directory: website
      - name: Build
        run: npm run build
        working-directory: website
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./website/build
```

---

## Success Message

```
"Documentation site initialized for this project!

Created:
- docs/.diataxis.md (project configuration)
- [website/ | docs/] (documentation structure)
- [.github/workflows/docs.yml] (if GitHub Pages)

Your configuration:
- Purpose: [chosen purpose]
- Technology: [chosen tech]
- Primary audience: [primary role]
- Sources: [list of selected sources]

Next steps:
- 'Plan documentation for this project' - analyze gaps based on sources
- 'Create a tutorial for getting started' - write content
- 'Organize existing docs' - restructure if you have existing content"
```

---

## References

- `Standard.md` - Diataxis framework documentation
- `PlanDocumentation.md` - Next step after initialization
- `CreateScaffold.md` - Create doc structure
- `GenerateContent.md` - Fill scaffold with content
