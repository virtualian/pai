# InitializeProject Workflow

**Trigger:** First use of Diataxis-Documentation skill in a project, OR explicit "set up docs", "initialize documentation", "create docs site".

**Purpose:** Configure and scaffold a documentation site for this specific project.

---

## Version Check (Run First)

**Check for skill updates before proceeding:**

```bash
SKILL_FILE="${PAI_DIR:-$HOME/.claude}/skills/Diataxis-Documentation/SKILL.md"

# Read version and sources from frontmatter
INSTALLED_VERSION=$(grep -E "^version:" "$SKILL_FILE" | cut -d' ' -f2)
OFFICIAL_SOURCE=$(grep -E "^official_source:" "$SKILL_FILE" | cut -d' ' -f2)
OFFICIAL_PATH=$(grep -E "^official_source_path:" "$SKILL_FILE" | cut -d' ' -f2)

# Defaults
OFFICIAL_SOURCE="${OFFICIAL_SOURCE:-https://github.com/danielmiessler/Personal_AI_Infrastructure}"
OFFICIAL_PATH="${OFFICIAL_PATH:-Packs/pai-diataxis-documentation-skill}"

# Fetch latest version from official source
RAW_URL=$(echo "$OFFICIAL_SOURCE" | sed 's|github.com|raw.githubusercontent.com|')
REMOTE_SKILL="$RAW_URL/main/$OFFICIAL_PATH/src/skills/Diataxis-Documentation/SKILL.md"

LATEST_VERSION=$(curl -s "$REMOTE_SKILL" 2>/dev/null | grep -E "^version:" | head -1 | cut -d' ' -f2 || echo "unknown")

echo "Installed: $INSTALLED_VERSION"
echo "Latest: $LATEST_VERSION"

if [ "$LATEST_VERSION" != "unknown" ] && [ "$INSTALLED_VERSION" != "$LATEST_VERSION" ]; then
  echo ""
  echo "â¬†ï¸ UPDATE AVAILABLE: $INSTALLED_VERSION â†’ $LATEST_VERSION"
fi
```

**If update available, inform user:**
```
"Note: A newer version of Diataxis-Documentation skill is available ($INSTALLED_VERSION â†’ $LATEST_VERSION).
You can update later with: 'check for Diataxis skill updates'

Continuing with initialization..."
```

---

## Detection & Resume

**Check for existing project configuration and determine mode:**

```bash
mkdir -p ./docs

if [ -f "./docs/.diataxis.md" ]; then
  INIT_STATUS=$(grep -E "^init_status:" ./docs/.diataxis.md | sed 's/^init_status: //')
  if [ "$INIT_STATUS" = "complete" ]; then
    echo "STATUS: complete"
  elif [ "$INIT_STATUS" = "in_progress" ]; then
    echo "STATUS: in_progress"
    echo ""
    echo "=== Saved Answers ==="
    grep -E "^(sources|purpose|roles|diataxis_|hosting|technology):" ./docs/.diataxis.md || echo "(none)"
  else
    echo "STATUS: unknown (treating as in_progress)"
  fi
else
  echo "STATUS: none"
fi
```

**Mode handling:**

| Status | Action |
|--------|--------|
| `complete` | Skip to other workflows (PlanDocumentation, etc.) |
| `in_progress` | Resume mode - show saved answers, offer to modify or continue |
| `none` | Fresh start - begin from Question 1 |

### Resume Mode (if in_progress)

**Present saved answers and ask how to proceed:**

```json
{
  "header": "Resume",
  "question": "Found incomplete initialization. How would you like to proceed?",
  "multiSelect": false,
  "options": [
    {"label": "Continue from where I left off", "description": "Keep saved answers, continue to next unanswered question"},
    {"label": "Review and modify answers", "description": "Go through each saved answer with option to change"},
    {"label": "Start fresh", "description": "Clear saved answers and restart from beginning"}
  ]
}
```

**If "Review and modify":** For each saved answer, show current value and ask:
```
"Sources: [Existing docs/, Code comments]
Keep this answer or change it?"
```

**If "Start fresh":**
```bash
rm -f ./docs/.diataxis.md
```

---

## Progressive Save Format

**After EACH question is answered, immediately save to `docs/.diataxis.md`:**

```bash
# Create/update config file with current progress
cat > ./docs/.diataxis.md << 'EOF'
<!-- Diataxis Documentation Configuration -->
<!-- Auto-generated by InitializeProject workflow -->

init_status: in_progress

## Saved Answers (in progress)

sources: [list of selected sources]
purpose: [selected purpose]
roles: [list of selected roles]
diataxis_developers: [list of content types]
diataxis_users: [list of content types]
hosting: [selected hosting]
technology: [selected technology]
EOF
```

**Questions are saved with these keys:**
- Phase 1 â†’ `sources:`
- Phase 2 â†’ `context:` (within_project | standalone_docs)
- Q2 â†’ `purpose:`
- Q3 â†’ `roles:`
- Q4 â†’ `diataxis_<role>:` (one per role)
- Q5 â†’ `hosting:`
- Q6 â†’ `technology:`

---

## Phase 1: Ask Sources First

**CRITICAL:** Ask what sources the user wants to use BEFORE analyzing the project. Only analyze selected sources.

### Question 1: Sources

**After answer, save immediately:**
```bash
# Example: user selected "Existing docs/" and "Code comments"
mkdir -p ./docs
cat > ./docs/.diataxis.md << 'EOF'
init_status: in_progress
sources: Existing docs/, Code comments
EOF
```

```json
{
  "header": "Sources",
  "question": "What sources should inform your documentation?",
  "multiSelect": true,
  "options": [
    {"label": "Existing docs/", "description": "Current documentation directory (if exists)"},
    {"label": "Code comments", "description": "JSDoc, docstrings, inline documentation"},
    {"label": "README files", "description": "Project and package READMEs"},
    {"label": "API specifications", "description": "OpenAPI/Swagger specs (if exists)"},
    {"label": "Design documents", "description": "specs/, rfcs/, design/ directories"}
  ]
}
```

---

## Phase 2: Analyze Selected Sources

**Only analyze sources the user selected in Phase 1.**

### 2.1 Project Context Detection (always run)

```bash
# Detect if this is a code project or standalone docs repo
HAS_CODE=false
PROJECT_TYPE="Unknown"

if [ -f "package.json" ]; then
  HAS_CODE=true
  PROJECT_TYPE="Node.js"
elif [ -f "pyproject.toml" ] || [ -f "setup.py" ] || [ -f "requirements.txt" ]; then
  HAS_CODE=true
  PROJECT_TYPE="Python"
elif [ -f "go.mod" ]; then
  HAS_CODE=true
  PROJECT_TYPE="Go"
elif [ -f "Cargo.toml" ]; then
  HAS_CODE=true
  PROJECT_TYPE="Rust"
elif [ -f "pom.xml" ] || [ -f "build.gradle" ]; then
  HAS_CODE=true
  PROJECT_TYPE="Java"
elif [ -d "src" ] || [ -d "lib" ] || [ -d "app" ]; then
  HAS_CODE=true
  PROJECT_TYPE="Unknown (has src/lib/app)"
fi

# Check for existing docs infrastructure
HAS_DOCS_SITE=false
[ -f "docusaurus.config.js" ] && HAS_DOCS_SITE=true && DOCS_TECH="Docusaurus"
[ -f "mkdocs.yml" ] && HAS_DOCS_SITE=true && DOCS_TECH="MkDocs"

# Determine likely context
if [ "$HAS_CODE" = "true" ]; then
  echo "CONTEXT_GUESS: within_project"
  echo "PROJECT_TYPE: $PROJECT_TYPE"
else
  echo "CONTEXT_GUESS: standalone_docs"
fi

echo "HAS_EXISTING_DOCS_SITE: $HAS_DOCS_SITE"

# Check repo visibility (for hosting recommendations)
if command -v gh &> /dev/null && [ -d ".git" ]; then
  REPO_VISIBILITY=$(gh repo view --json visibility -q '.visibility' 2>/dev/null || echo "unknown")
  echo "REPO_VISIBILITY: $REPO_VISIBILITY"
else
  echo "REPO_VISIBILITY: unknown"
fi
```

### 2.2 Confirm Documentation Context

**Based on detection, confirm with user:**

```json
{
  "header": "Context",
  "question": "Where are you creating this documentation?",
  "multiSelect": false,
  "options": [
    {"label": "Within a project (Recommended)", "description": "Adding docs to an existing codebase - creates docs/ folder alongside code"},
    {"label": "Standalone docs repo", "description": "Dedicated documentation repository - site lives at root level"}
  ]
}
```

**Recommendation logic:**
- If `HAS_CODE=true` â†’ recommend "Within a project"
- If `HAS_CODE=false` â†’ recommend "Standalone docs repo"

**After answer, save immediately:**
```bash
echo "context: [within_project | standalone_docs]" >> ./docs/.diataxis.md
```

**This affects site structure:**

| Context | Docs Location | Site Location |
|---------|---------------|---------------|
| Within project | `docs/` | `website/` (Docusaurus) or `site/` (MkDocs) |
| Standalone docs | root or `docs/` | root level build |

### 2.3 Analyze Selected Sources Only

**If user selected "Existing docs/":**
```bash
if [ -d "./docs" ]; then
  DOC_COUNT=$(find ./docs -name "*.md" 2>/dev/null | wc -l | tr -d ' ')
  echo "EXISTING_DOCS: $DOC_COUNT markdown files"
  find ./docs -name "*.md" -type f | head -20
else
  echo "EXISTING_DOCS: No docs/ directory found"
fi
```

**If user selected "Code comments":**
```bash
# Check for JSDoc/TSDoc
JSDOC_COUNT=$(grep -r "^\s*/\*\*" --include="*.ts" --include="*.js" . 2>/dev/null | wc -l | tr -d ' ')
echo "JSDOC_COMMENTS: $JSDOC_COUNT blocks found"

# Check for Python docstrings
DOCSTRING_COUNT=$(grep -r '"""' --include="*.py" . 2>/dev/null | wc -l | tr -d ' ')
echo "PYTHON_DOCSTRINGS: $DOCSTRING_COUNT found"
```

**If user selected "README files":**
```bash
README_COUNT=$(find . -maxdepth 3 -name "README*.md" 2>/dev/null | wc -l | tr -d ' ')
echo "README_FILES: $README_COUNT"
[ -f "README.md" ] && head -50 README.md
```

**If user selected "API specifications":**
```bash
[ -f "openapi.yaml" ] && echo "OPENAPI_SPEC: openapi.yaml found"
[ -f "openapi.json" ] && echo "OPENAPI_SPEC: openapi.json found"
[ -f "swagger.yaml" ] && echo "OPENAPI_SPEC: swagger.yaml found"
```

**If user selected "Design documents":**
```bash
[ -d "./specs" ] && echo "DESIGN_DOCS: specs/ found" && ls ./specs/
[ -d "./rfcs" ] && echo "DESIGN_DOCS: rfcs/ found" && ls ./rfcs/
[ -d "./design" ] && echo "DESIGN_DOCS: design/ found" && ls ./design/
```

### 2.4 Check for Existing Docs Site

```bash
[ -f "docusaurus.config.js" ] && echo "EXISTING_SITE: Docusaurus"
[ -f "mkdocs.yml" ] && echo "EXISTING_SITE: MkDocs"
```

### 2.5 Present Analysis

```
"Based on your selected sources, here's what I found:

ðŸ”§ Project type: [Node.js | Python | Go | etc.]
ðŸ”’ Repo visibility: [Public | Private | Unknown]

[For each selected source, show what was found]

Note: Private repos require GitHub Enterprise for GitHub Pages, or use Vercel/Netlify instead."
```

---

## Phase 3: Remaining Questions

**IMPORTANT:** Ask remaining 5 questions. Each builds on sources selected AND analysis from Phase 2.

### Question Order (Dependencies)

```
Sources âœ“ (Phase 1)
    â†“
Context âœ“ (Phase 2 - within project vs standalone)
    â†“
Purpose (informed by context + sources)
    â†“
Roles (informed by purpose + sources)
    â†“
Diataxis Priorities (informed by roles + sources)
    â†“
Hosting (informed by purpose + repo visibility)
    â†“
Technology (informed by hosting + purpose + project type)
```

---

### Question 2: Purpose (first question in Phase 3)

**Recommend based on sources found.**

```json
{
  "header": "Purpose",
  "question": "What is the primary purpose of your documentation site?",
  "multiSelect": false,
  "options": [
    {"label": "Developer Portal (Recommended)", "description": "API docs, SDK guides, integration tutorials for developers"},
    {"label": "Product Documentation", "description": "User guides, feature docs, help center for end users"},
    {"label": "Internal/Team Docs", "description": "Engineering docs, runbooks, architecture decisions"},
    {"label": "Open Source Project", "description": "README-driven, contributor guides, community docs"}
  ]
}
```

**Recommendation logic based on sources:**

| Sources Found | Recommended Purpose |
|--------------|---------------------|
| OpenAPI spec, JSDoc, API code | Developer Portal |
| User-facing app, no API | Product Documentation |
| Internal tooling, runbooks | Internal/Team Docs |
| GitHub public repo, CONTRIBUTING.md | Open Source Project |

**After answer, save immediately:**
```bash
# Append purpose to config
echo "purpose: [selected purpose]" >> ./docs/.diataxis.md
```

---

### Question 3: Roles/Audiences

**Recommend based on purpose + sources.**

```json
{
  "header": "Roles",
  "question": "What roles/audiences does your documentation serve?",
  "multiSelect": true,
  "options": [
    {"label": "Developers", "description": "People writing code against your project"},
    {"label": "Users", "description": "End users of your application or library"},
    {"label": "Operators", "description": "DevOps, SRE, people deploying and running your system"},
    {"label": "Contributors", "description": "Open source contributors to your project"}
  ]
}
```

**Recommendation logic:**

| Purpose | Recommended Roles |
|---------|-------------------|
| Developer Portal | Developers (primary), Operators |
| Product Documentation | Users (primary), Operators |
| Internal/Team Docs | Developers, Operators |
| Open Source Project | Developers, Contributors |

**After answer, save immediately:**
```bash
# Append roles to config
echo "roles: [selected roles]" >> ./docs/.diataxis.md
```

---

### Question 4: Diataxis Priorities

**Ask for EACH role selected. Recommendations based on available sources.**

```json
{
  "header": "[Role] Docs",
  "question": "For [ROLE], which Diataxis content types are most important?",
  "multiSelect": true,
  "options": [
    {"label": "How-to Guides", "description": "Task-oriented guides for accomplishing specific goals"},
    {"label": "Reference", "description": "Technical specifications, API docs, configuration options"},
    {"label": "Tutorials", "description": "Learning-oriented content for newcomers"},
    {"label": "Explanation", "description": "Conceptual content explaining why things work"}
  ]
}
```

**Recommendation logic based on sources:**

| Source Available | Can Recommend |
|-----------------|---------------|
| OpenAPI spec, JSDoc | Reference âœ“ |
| Existing tutorials in docs/ | Tutorials âœ“ |
| Code examples | How-to Guides âœ“ |
| Design docs, architecture | Explanation âœ“ |

**If source doesn't exist for a content type, note it:**
```
"Note: Reference docs recommended, but I didn't find API specs or JSDoc.
You'll need to add code comments or manually write reference content."
```

**After answer (for each role), save immediately:**
```bash
# Append diataxis priorities per role
echo "diataxis_developers: [selected content types]" >> ./docs/.diataxis.md
echo "diataxis_users: [selected content types]" >> ./docs/.diataxis.md
# etc. for each role
```

---

### Question 5: Hosting

**Recommend based on purpose + repo visibility.**

```json
{
  "header": "Hosting",
  "question": "Where will your documentation be hosted?",
  "multiSelect": false,
  "options": [
    {"label": "GitHub Pages", "description": "Free, git-integrated, works with most static site generators"},
    {"label": "Vercel/Netlify", "description": "Modern JAMstack hosting with preview deployments"},
    {"label": "Self-hosted", "description": "Your own infrastructure (nginx, S3, etc.)"},
    {"label": "Docs platform", "description": "ReadMe, GitBook, Notion, or similar managed platform"}
  ]
}
```

**Recommendation logic:**

| Factors | Recommended Hosting |
|---------|-------------------|
| Public GitHub repo | GitHub Pages (free, integrated) |
| Private repo (no Enterprise) | Vercel/Netlify (free tier available) |
| Private repo + GitHub Enterprise | GitHub Pages or Vercel/Netlify |
| Enterprise/on-prem requirements | Self-hosted |
| Managed experience preferred | Docs platform (ReadMe, GitBook) |

**Note:** GitHub Pages requires public repos OR GitHub Enterprise subscription for private repos.

**After answer, save immediately:**
```bash
echo "hosting: [selected hosting]" >> ./docs/.diataxis.md
```

---

### Question 6: Technology

**Recommend based on hosting + purpose + project type.**

```json
{
  "header": "Technology",
  "question": "Which documentation technology should we use?",
  "multiSelect": false,
  "options": [
    {"label": "Docusaurus", "description": "React-based, versioning, search, MDX support - great for developer portals"},
    {"label": "MkDocs + Material", "description": "Python-based, clean design, simpler setup - great for technical docs"},
    {"label": "Astro Starlight", "description": "Fast, modern, component islands - great for performance"},
    {"label": "Plain Markdown", "description": "No build step, GitHub renders directly - great for simple projects"}
  ]
}
```

**Recommendation logic:**

| Factors | Recommended Technology |
|---------|----------------------|
| Docs platform (ReadMe, GitBook) | Plain Markdown (platform handles rendering) |
| GitHub Pages + simple project | Plain Markdown |
| Node.js project + Developer Portal | Docusaurus |
| Python project + any purpose | MkDocs Material |
| Existing Docusaurus setup | Docusaurus (keep existing) |
| Existing MkDocs setup | MkDocs (keep existing) |
| Performance critical | Astro Starlight |

**After answer, save immediately:**
```bash
echo "technology: [selected technology]" >> ./docs/.diataxis.md
```

---

## Phase 4: Scaffold Documentation Site

**Based on context AND technology choice, scaffold the docs site.**

**Read context from saved answers:**
```bash
CONTEXT=$(grep -E "^context:" ./docs/.diataxis.md | sed 's/^context: //')
```

---

### Docusaurus

**Within project:**
```bash
# Site in website/, docs content in website/docs/
npx create-docusaurus@latest website classic --typescript
```

```
project/
â”œâ”€â”€ src/                    # Your code
â”œâ”€â”€ website/                # Docusaurus site
â”‚   â”œâ”€â”€ docs/               # Documentation content (Diataxis-organized)
â”‚   â”œâ”€â”€ src/                # Custom pages, components
â”‚   â”œâ”€â”€ docusaurus.config.js
â”‚   â””â”€â”€ sidebars.js
â””â”€â”€ package.json            # Your project
```

**Standalone docs repo:**
```bash
# Site at root level
npx create-docusaurus@latest . classic --typescript
```

```
docs-repo/
â”œâ”€â”€ docs/                   # Documentation content (Diataxis-organized)
â”œâ”€â”€ src/                    # Custom pages, components
â”œâ”€â”€ docusaurus.config.js
â””â”€â”€ sidebars.js
```

---

### MkDocs + Material

**Within project:**
```bash
mkdir -p docs
pip install mkdocs-material  # or add to requirements.txt
```

```
project/
â”œâ”€â”€ src/                    # Your code
â”œâ”€â”€ docs/                   # Documentation content
â”‚   â”œâ”€â”€ index.md
â”‚   â”œâ”€â”€ tutorials/
â”‚   â”œâ”€â”€ how-to/
â”‚   â”œâ”€â”€ reference/
â”‚   â””â”€â”€ explanation/
â”œâ”€â”€ mkdocs.yml              # MkDocs config at project root
â””â”€â”€ package.json            # Your project
```

**Standalone docs repo:**
```bash
mkdir -p docs
pip install mkdocs-material
```

```
docs-repo/
â”œâ”€â”€ docs/                   # Documentation content
â”‚   â”œâ”€â”€ index.md
â”‚   â”œâ”€â”€ tutorials/
â”‚   â”œâ”€â”€ how-to/
â”‚   â”œâ”€â”€ reference/
â”‚   â””â”€â”€ explanation/
â””â”€â”€ mkdocs.yml
```

---

### Plain Markdown

**Within project:**
```bash
mkdir -p docs/{tutorials,how-to,reference,explanation}
```

```
project/
â”œâ”€â”€ src/                    # Your code
â”œâ”€â”€ docs/                   # Documentation
â”‚   â”œâ”€â”€ README.md           # Index
â”‚   â”œâ”€â”€ tutorials/
â”‚   â”œâ”€â”€ how-to/
â”‚   â”œâ”€â”€ reference/
â”‚   â””â”€â”€ explanation/
â””â”€â”€ README.md               # Project readme (not Diataxis)
```

**Standalone docs repo:**
```bash
mkdir -p {tutorials,how-to,reference,explanation}
```

```
docs-repo/
â”œâ”€â”€ README.md               # Index
â”œâ”€â”€ tutorials/
â”œâ”€â”€ how-to/
â”œâ”€â”€ reference/
â””â”€â”€ explanation/
```

---

## Phase 5: Finalize Project Configuration

**Transform progressive saves into final config format and mark complete.**

**Read skill version and saved answers:**

```bash
SKILL_VERSION=$(grep -E "^version:" "${PAI_DIR:-$HOME/.claude}/skills/Diataxis-Documentation/SKILL.md" | cut -d' ' -f2)

# Read saved answers from progressive saves
SOURCES=$(grep -E "^sources:" ./docs/.diataxis.md | sed 's/^sources: //')
CONTEXT=$(grep -E "^context:" ./docs/.diataxis.md | sed 's/^context: //')
PURPOSE=$(grep -E "^purpose:" ./docs/.diataxis.md | sed 's/^purpose: //')
ROLES=$(grep -E "^roles:" ./docs/.diataxis.md | sed 's/^roles: //')
HOSTING=$(grep -E "^hosting:" ./docs/.diataxis.md | sed 's/^hosting: //')
TECHNOLOGY=$(grep -E "^technology:" ./docs/.diataxis.md | sed 's/^technology: //')
```

**Rewrite `docs/.diataxis.md` as final config (with init_status: complete):**

```bash
# Get current date
CURRENT_DATE=$(date +%Y-%m-%d)

# Read diataxis priorities for each role (if they exist)
DIATAXIS_DEVELOPERS=$(grep -E "^diataxis_developers:" ./docs/.diataxis.md 2>/dev/null | sed 's/^diataxis_developers: //' || echo "")
DIATAXIS_USERS=$(grep -E "^diataxis_users:" ./docs/.diataxis.md 2>/dev/null | sed 's/^diataxis_users: //' || echo "")
DIATAXIS_OPERATORS=$(grep -E "^diataxis_operators:" ./docs/.diataxis.md 2>/dev/null | sed 's/^diataxis_operators: //' || echo "")
DIATAXIS_CONTRIBUTORS=$(grep -E "^diataxis_contributors:" ./docs/.diataxis.md 2>/dev/null | sed 's/^diataxis_contributors: //' || echo "")

# Write final configuration file
cat > ./docs/.diataxis.md << EOF
<!-- config-version: $SKILL_VERSION -->
# Diataxis Documentation Configuration

> Auto-generated by Diataxis-Documentation skill v$SKILL_VERSION on $CURRENT_DATE

init_status: complete

## Site Configuration

- **Context:** $CONTEXT
- **Purpose:** $PURPOSE
- **Hosting:** $HOSTING
- **Technology:** $TECHNOLOGY

## Documentation Sources

$SOURCES

## Roles & Audiences

| Role | Priority |
|------|----------|
$(echo "$ROLES" | tr ',' '\n' | tr '[:upper:]' '[:lower:]' | head -1 | xargs -I {} echo "| {} | primary |")
$(echo "$ROLES" | tr ',' '\n' | tr '[:upper:]' '[:lower:]' | tail -n +2 | head -1 | xargs -I {} echo "| {} | secondary |")
$(echo "$ROLES" | tr ',' '\n' | tr '[:upper:]' '[:lower:]' | tail -n +3 | xargs -I {} echo "| {} | tertiary |")

## Diataxis Elements by Role

| Role | Tutorials | How-to | Reference | Explanation |
|------|-----------|--------|-----------|-------------|
$(echo "$ROLES" | tr ',' '\n' | tr '[:upper:]' '[:lower:]' | while read role; do
  role=$(echo "$role" | xargs)  # trim whitespace
  [ -z "$role" ] && continue
  case "$role" in
    developers) priorities="$DIATAXIS_DEVELOPERS" ;;
    users) priorities="$DIATAXIS_USERS" ;;
    operators) priorities="$DIATAXIS_OPERATORS" ;;
    contributors) priorities="$DIATAXIS_CONTRIBUTORS" ;;
    *) priorities="" ;;
  esac
  if [ -n "$priorities" ]; then
    echo "| $role | $priorities |"
  else
    echo "| $role | (not configured) | | | |"
  fi
done)

## Scope Exclusions

Standard repo files (outside Diataxis scope):
- README.md, LICENSE, CONTRIBUTING.md, CHANGELOG.md
- CODE_OF_CONDUCT.md, SECURITY.md, .github/*.md
- SKILL.md files (PAI skills)

Custom exclusions:
- (none configured)
EOF

echo "âœ“ Configuration finalized: ./docs/.diataxis.md"
```

**CRITICAL:** The `init_status: complete` line marks initialization as finished. Without this, the workflow will treat the project as incomplete on next invocation.

---

## Phase 6: Create Initial Structure

Based on role priorities and available sources, create starter files:

```bash
# Example for Docusaurus with developers as primary role
mkdir -p website/docs/{how-to,reference,explanation}

# Create index
cat > website/docs/intro.md << 'EOF'
---
sidebar_position: 1
---

# Introduction

Welcome to the documentation.

[TODO: Add project overview]
EOF

# Create placeholder for each priority type
cat > website/docs/how-to/index.md << 'EOF'
# How-to Guides

Task-oriented guides for accomplishing specific goals.

[TODO: Add how-to guides]
EOF
```

---

## Phase 7: GitHub Actions (if GitHub Pages)

**If hosting is GitHub Pages, create workflow:**

```yaml
# .github/workflows/docs.yml
name: Deploy Documentation

on:
  push:
    branches: [main]
    paths:
      - 'website/**'
      - 'docs/**'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Install dependencies
        run: npm ci
        working-directory: website
      - name: Build
        run: npm run build
        working-directory: website
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./website/build
```

---

## Success Message

```
"Documentation site initialized for this project!

Created:
- docs/.diataxis.md (project configuration)
- [website/ | docs/] (documentation structure)
- [.github/workflows/docs.yml] (if GitHub Pages)

Your configuration:
- Purpose: [chosen purpose]
- Technology: [chosen tech]
- Primary audience: [primary role]
- Sources: [list of selected sources]

Next steps:
- 'Plan documentation for this project' - analyze gaps based on sources
- 'Create a tutorial for getting started' - write content
- 'Organize existing docs' - restructure if you have existing content"
```

---

## References

- `Standard.md` - Diataxis framework documentation
- `PlanDocumentation.md` - Next step after initialization
- `CreateScaffold.md` - Create doc structure
- `GenerateContent.md` - Fill scaffold with content
